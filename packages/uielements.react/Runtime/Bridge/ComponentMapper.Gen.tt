<#@ template language="C#" #>
<#@ output extension=".cs" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="C:\Projects\unity-react-uielements\examples\Library\ScriptAssemblies\Unity.UI.Runtime.dll" #>
<#@ assembly name="C:\Program Files\Unity\Hub\Editor\2019.3.14f1\Editor\Data\Managed\UnityEngine\UnityEngine.UIElementsModule.dll" #>

<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="UnityEngine.UIElements" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>

<#
    var visualElementType = typeof(VisualElement);
    var allTypes = visualElementType.Assembly
        .GetTypes()
        .Where(e => e.IsPublic &&
                    !e.IsAbstract &&
                    !e.IsGenericTypeDefinition &&
                    !e.IsNested &&
                    visualElementType.IsAssignableFrom(e));

    var eventBaseType = typeof(EventBase);
    var allEventTypes = eventBaseType.Assembly
        .GetTypes()
        .Where(e => e.IsPublic &&
                    !e.IsAbstract &&
                    !e.IsGenericTypeDefinition &&
                    !e.IsNested &&
                    eventBaseType.IsAssignableFrom(e));

    Func<Type, string> GetReactFriendlyName = (Type t) =>
    {
        return t.Name.Substring(0, 1).ToLower() + t.Name.Substring(1);
    };

    Func<Type, bool, string> CSharpName = null;
    CSharpName  = (Type type, bool withNamespace) =>
    {
        var sb = new StringBuilder();
        var name = withNamespace
            ? type.Namespace + "." + type.Name
            : type.Name;

        if (!type.IsGenericType) return name;
        sb.Append(name.Substring(0, name.IndexOf('`')));
        sb.Append("<");
        sb.Append(string.Join(", ", type.GetGenericArguments()
                                        .Select(t => CSharpName(t, withNamespace))));
        sb.Append(">");
        return sb.ToString();
    };
#>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;
using ChakraHost.Hosting;
using UnityReactUIElements.Bridge;

namespace UnityReactUIElements.Bridge
{
    internal static partial class ComponentMapper
    {
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of CreateComponent method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        public static VisualElement CreateComponent(string componentType)
        {
<#
            foreach (var type in allTypes)
            {
#>
            if (componentType == "<#=GetReactFriendlyName(type)#>") return new React<#=type.Name#>();
<#
            }
#>
            throw new InvalidOperationException($"Unknown native component type {componentType}");
        }

<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of MakePropsDiff method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>

        public static IComponentProps MakePropsDiff(string componentType, IComponentProps oldProps, IComponentProps newProps)
        {
<#
            foreach (var type in allTypes)
            {
#>
            if (componentType == "<#=GetReactFriendlyName(type)#>") return Make<#=type.Name#>PropsDiff((<#=type.Name#>Props)oldProps, (<#=type.Name#>Props)newProps);
<#
            }
#>
            throw new InvalidOperationException($"Unknown native component type {componentType}");
        }
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of CreateProps method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        public static IComponentProps CreateProps(string componentType, JavaScriptValue props)
        {
<#
            foreach (var type in allTypes)
            {
#>
            if (componentType == "<#=GetReactFriendlyName(type)#>") return Create<#=type.Name#>Props(props);
<#
            }
#>
            throw new InvalidOperationException($"Unknown native component type {componentType}");
        }
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of ApplyProps method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        public static void ApplyProps(string componentType, VisualElement element, IComponentProps props)
        {

            if (false) {}
<#
            foreach (var type in allTypes)
            {
#>
            else if (componentType == "<#=GetReactFriendlyName(type)#>") Apply<#=type.Name#>Props((React<#=type.Name#>)element, (<#=type.Name#>Props)props);
<#
            }
#>
            else throw new InvalidOperationException($"Unknown native component type {componentType}");
        }
<#
    foreach (var type in allTypes) {

        var properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public)
            .Where(e =>
                e.CanRead &&
                e.CanWrite &&
                e.SetMethod.IsPublic &&
                e.GetMethod.IsPublic &&
                !e.PropertyType.IsGenericType &&
                !e.PropertyType.IsNested);

#>
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of Component types
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        ///<Component>
        ///Name:<#=GetReactFriendlyName(type)#>
        internal class React<#=type.Name#> : <#=CSharpName(type, true)#>
        {
            private Dictionary<string, (Delegate, JavaScriptValue)> previousCallbacks = new Dictionary<string, (Delegate, JavaScriptValue)>();

            public void SetCallback<TEventType>(UnityEngine.UIElements.EventCallback<TEventType> callback, JavaScriptValue function) where TEventType : EventBase<TEventType>, new()
            {
                var t = typeof(TEventType);

                if (previousCallbacks.ContainsKey(t.Name))
                {
                    this.UnregisterCallback<TEventType>((UnityEngine.UIElements.EventCallback<TEventType>)previousCallbacks[t.Name].Item1);
                    
                    if (previousCallbacks[t.Name].Item2.IsValid)
                        previousCallbacks[t.Name].Item2.Release();

                    previousCallbacks.Remove(t.Name);
                }

                this.RegisterCallback(callback);

                previousCallbacks.Add(t.Name, (callback, function));
            }
        }   
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of Prop types
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        public struct <#=type.Name#>Props : IComponentProps
        {
            public StyleProps style;
<#
        foreach (var property in properties) {
            if (property.PropertyType.IsValueType) {
#>
            public Nullable<<#=CSharpName(property.PropertyType, true)#>> <#=property.Name#>; 
<#           
            }
            else
            {
#>
            public <#=CSharpName(property.PropertyType, true)#> <#=property.Name#>; 
<#
            }
        }
#>         
<#
        foreach (var eventType in allEventTypes) {
#>
            public UnityEngine.UIElements.EventCallback<<#=eventType.Name#>> on<#=eventType.Name#>;
            public JavaScriptValue on<#=eventType.Name#>Function;
<#         
        }
#>          public UnityEngine.UIElements.EventCallback<ChangeEvent<string>> onChange;
            public JavaScriptValue onChangeFunction;
        }
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of Create[Component]Props method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        private static IComponentProps Create<#=type.Name#>Props(JavaScriptValue props)
        {
            var result = new <#=type.Name#>Props();
<#
        foreach (var property in properties) {
#>
            if (props.HasProperty(JavaScriptPropertyId.FromString("<#=property.Name#>")))
            {
<#
            if (property.PropertyType == typeof(string)) {
#>
                result.<#=property.Name#> = props.GetProperty(JavaScriptPropertyId.FromString("<#=property.Name#>")).ToString();
<#
            } else if (property.PropertyType == typeof(object)) {
#>
                result.<#=property.Name#> = props.GetProperty(JavaScriptPropertyId.FromString("<#=property.Name#>")).ToString();
<#
            }
            else {
#>
                // TODO: Implement
<#
            }
#>          
            }
<#
        }
#>
<#
        foreach (var eventType in allEventTypes) {
#>
            if (props.HasProperty(JavaScriptPropertyId.FromString("on<#=eventType.Name#>")))
            {
                var function =  props.GetProperty(JavaScriptPropertyId.FromString("on<#=eventType.Name#>"));
                if (function.ValueType == JavaScriptValueType.Function)
                {
                    function.AddRef();
                    result.on<#=eventType.Name#>Function = function;
                    result.on<#=eventType.Name#> = (<#=CSharpName(eventType, false)#> evt) => {
                        if (function.IsValid)
                        {
                            function.CallFunction(JavaScriptValue.Undefined);
                        }
                    };
                }
            }
<#         
        }
#>  
            // TODO: generate this in a better manner
            if (props.HasProperty(JavaScriptPropertyId.FromString("onChange")))
            {
                var function =  props.GetProperty(JavaScriptPropertyId.FromString("onChange"));
                if (function.ValueType == JavaScriptValueType.Function)
                {
                    function.AddRef();
                    result.onChangeFunction = function;
                    result.onChange = (ChangeEvent<string> evt) => {
                        if (function.IsValid)
                        {
                            function.CallFunction(JavaScriptValue.Undefined, JavaScriptValue.FromString(evt.newValue));
                        }
                    };
                }
            }

            if (props.HasProperty(JavaScriptPropertyId.FromString("style")))
            {
                result.style = MapStyle(props.GetProperty(JavaScriptPropertyId.FromString("style")));
            }

            return result;
        }
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of Apply[Component]Props method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        private static void Apply<#=type.Name#>Props(React<#=type.Name#> component, <#=type.Name#>Props props)
        {
<#
        foreach (var property in properties)
        {
            if (property.PropertyType.IsValueType)
            {
#>
            if (props.<#=property.Name#>.HasValue)
            {
                component.<#=property.Name#> = props.<#=property.Name#>.Value;
            }
<#           
            }
            else
            {
#>
            if (props.<#=property.Name#> != null)
            {
                component.<#=property.Name#> = props.<#=property.Name#>;
            }
<#
            }
#>
<#
        }
#>
<#
        foreach (var eventType in allEventTypes) {
#>
            if (props.on<#=eventType.Name#> != null)
            {
                component.SetCallback(props.on<#=eventType.Name#>, props.on<#=eventType.Name#>Function);
            }
<#         
        }
#>  

            if (props.onChange != null)
            {
                component.SetCallback(props.onChange, props.onChangeFunction);
            }

            if (props.style != null)
            {
                ApplyStyle(component, props.style);
            }
        }
<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of Make[Component]PropsDiff method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>
        private static <#=type.Name#>Props Make<#=type.Name#>PropsDiff(<#=type.Name#>Props oldProps, <#=type.Name#>Props newProps)
        {
            var result = new <#=type.Name#>Props();
<#
        foreach (var property in properties)
        {
#>
            if (oldProps.<#=property.Name#> != newProps.<#=property.Name#>)
            {
                result.<#=property.Name#> = newProps.<#=property.Name#>;
            }
<#
        }
#>
<#
        foreach (var eventType in allEventTypes)
        {
#>
            if (oldProps.on<#=eventType.Name#> != newProps.on<#=eventType.Name#>)
            {
                result.on<#=eventType.Name#> = newProps.on<#=eventType.Name#>;
            }
<#         
        }
#>  
            if (oldProps.onChange != newProps.onChange)
            {
                result.onChange = newProps.onChange;
            }

            if (oldProps.style != newProps.style)
            {
                result.style = newProps.style;
            }

            return result;
        }
<#
    }
#>

<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of StyleProps class
        ////////////////////////////////////////////////////////////////////////////////////////////
#>

<#
    var styleType = typeof(IStyle);
    var styleProperties = styleType.GetProperties();
#>
        internal class StyleProps
        {
<#
        foreach (var property in styleProperties) {
            if (property.PropertyType.IsValueType) {
#>
            public Nullable<<#=CSharpName(property.PropertyType, true)#>> <#=property.Name#>;
<#           
            }
            else
            {
#>
            public <#=CSharpName(property.PropertyType, true)#> <#=property.Name#>; 
<#
            }
        }
#>
        }

<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of MapStyle method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>

        private static StyleProps MapStyle(JavaScriptValue value)
        {
            var result = new StyleProps();
<#
        foreach (var property in styleProperties) {
            if (property.PropertyType.IsValueType) {
#>
            if (value.HasProperty(JavaScriptPropertyId.FromString("<#=property.Name#>")))
            {
                var stringValue = value.GetProperty(JavaScriptPropertyId.FromString("<#=property.Name#>")).ConvertToString().ToString();
                result.<#=property.Name#> = StyleMapper.Parse<#=CSharpName(property.PropertyType, false)#>(stringValue);
            }
<#
            }
        }
#>
            return result;
        }

<#
        ////////////////////////////////////////////////////////////////////////////////////////////
        // Generation of ApplyStyle method
        ////////////////////////////////////////////////////////////////////////////////////////////
#>

        private static void ApplyStyle(VisualElement element, StyleProps style)
        {
<#
        foreach (var property in styleProperties) {
            if (property.PropertyType.IsValueType) {
#>
            if (style.<#=property.Name#>.HasValue)
            {
                element.style.<#=property.Name#> = style.<#=property.Name#>.Value;
            }
<#
            }
        }
#>
        }
    }
}