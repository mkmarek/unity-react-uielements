//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using UnityEngine;
using UnityReactUIElements.Bridge;

namespace UnityReactUIElements
{
    public abstract class ReactUIElementsQuery<T0> : ReactUIElementsQuery
    where T0 : struct, IComponentData
    {
        private NativeList<T0> previous_0;
        private NativeList<ComponentDataUpdateRequest> componentUpdateRequests;
        private double lastTimeRun;

        [StructLayout(LayoutKind.Sequential)]
        private struct ComponentDataUpdateRequest
        {
            public int componentIndex;
            public int index;
            public T0 data_0;
        }

        public override void AddComponentDataUpdateRequest(int componentIndex, int index, string data)
        {
            var request = new ComponentDataUpdateRequest()
            {
                index = index,
                componentIndex = componentIndex
            };

            if (componentIndex == 0) {
                request.data_0 = JsonUtility.FromJson<T0>(data);
            }

            componentUpdateRequests.Add(request);
        }

        protected override void OnCreate()
        {
            previous_0 = new NativeList<T0>(Allocator.Persistent);
            executedQueries = new NativeList<Guid>(Allocator.Persistent);
            componentUpdateRequests = new NativeList<ComponentDataUpdateRequest>(Allocator.Persistent);

            base.OnCreate();
        }

        protected override void OnDestroy()
        {
            previous_0.Dispose();
            executedQueries.Dispose();
            componentUpdateRequests.Dispose();

            base.OnDestroy();
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct UpdateComponentsJob : IJobForEachWithEntity<T0>
        {
            [ReadOnly] public NativeList<ComponentDataUpdateRequest> componentUpdateRequests;

            public void Execute(Entity entity, int index, ref T0 t0)
            {
                for (var i = 0; i < componentUpdateRequests.Length; i++)
                {
                    var request = componentUpdateRequests[i];
                    if (request.componentIndex == 0 && request.index == index)
                    {
                        t0 = request.data_0;
                    }
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct ProcessQueriesJob : IJob
        {
            [WriteOnly] public NativeList<Guid> queriesToExecute;
            [WriteOnly] public NativeList<T0> previous_0;

            public NativeList<Guid> executedQueries;

            [ReadOnly] public NativeList<int> previousHashCodes_0;
            [ReadOnly] public NativeList<int> hashCodes_0;
            [ReadOnly] public NativeArray<T0> current_0;
            [ReadOnly] public NativeList<Guid> allQueries;

            public void Execute()
            {
                if (!ListEquals(previousHashCodes_0, hashCodes_0))
                {
                    executedQueries.Clear();
                    previous_0.Clear();
                    previous_0.AddRange(current_0);
                }

                for (var i = 0; i < allQueries.Length; i++)
                {
                    if (!ListContains(executedQueries, allQueries[i]))
                    {
                        queriesToExecute.Add(allQueries[i]);
                        executedQueries.Add(allQueries[i]);
                    }
                }
            }

            private bool ListEquals(NativeList<int> list1, NativeList<int> list2)
            {
                if (list1.Length != list2.Length) return false;

                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] != list2[i]) return false;
                }

                return true;
            }

            private bool ListContains(NativeList<Guid> list1, Guid element)
            {
                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] == element) return true;
                }

                return false;
            }
        }

        protected override JobHandle OnUpdate(JobHandle inputDeps)
        {
            var currentTime = Time.ElapsedTime * 1000;
            if (currentTime - lastTimeRun > 25) {
                lastTimeRun = currentTime;
            } else {
                return inputDeps;
            }
            if (queryIds.Length == 0) return inputDeps;

            var hashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var queriesToExecute = new NativeList<Guid>(Allocator.TempJob);

            var updateJob = new UpdateComponentsJob()
            {
                componentUpdateRequests = componentUpdateRequests
            };

            inputDeps = updateJob.Schedule(this, inputDeps);

            inputDeps.Complete();

            var query = EntityManager.CreateEntityQuery(typeof(T0));

            var list_0 = query.ToComponentDataArray<T0>(Allocator.TempJob);

            for (var i = 0; i < list_0.Length; i++)
            {
                hashCodes_0.Add(list_0[i].GetHashCode());
            }

            for (var i = 0; i < previous_0.Length; i++)
            {
                previousHashCodes_0.Add(previous_0[i].GetHashCode());
            }
            var queriesJob = new ProcessQueriesJob()
            {
                executedQueries = executedQueries,
                allQueries = queryIds,
                current_0 = list_0,
                hashCodes_0 = hashCodes_0,
                previous_0 = previous_0,
                previousHashCodes_0 = previousHashCodes_0,
                queriesToExecute = queriesToExecute
            };

            inputDeps = queriesJob.Schedule(inputDeps);

            inputDeps.Complete();

            var listOfJsonLists = new List<string>();
            listOfJsonLists.Add(ListToJson(list_0));
            var resultJson = $"[{string.Join(",", listOfJsonLists)}]";

            foreach (var queryId in queriesToExecute)
            {
                ReactRenderer.Current.AddMessageToBuffer(
                    NativeToJsBridgePayload.BridgeMessage.CreateUpdateComponentDataHookMessage(
                        queryId.ToString(), resultJson));
            }

            list_0.Dispose();
            hashCodes_0.Dispose();
            previousHashCodes_0.Dispose();
            queriesToExecute.Dispose();
            componentUpdateRequests.Clear();

            return inputDeps;
        }
    }
    public abstract class ReactUIElementsQuery<T0, T1> : ReactUIElementsQuery
    where T0 : struct, IComponentData
    where T1 : struct, IComponentData
    {
        private NativeList<T0> previous_0;
        private NativeList<T1> previous_1;
        private NativeList<ComponentDataUpdateRequest> componentUpdateRequests;
        private double lastTimeRun;

        [StructLayout(LayoutKind.Sequential)]
        private struct ComponentDataUpdateRequest
        {
            public int componentIndex;
            public int index;
            public T0 data_0;
            public T1 data_1;
        }

        public override void AddComponentDataUpdateRequest(int componentIndex, int index, string data)
        {
            var request = new ComponentDataUpdateRequest()
            {
                index = index,
                componentIndex = componentIndex
            };

            if (componentIndex == 0) {
                request.data_0 = JsonUtility.FromJson<T0>(data);
            }
            if (componentIndex == 1) {
                request.data_1 = JsonUtility.FromJson<T1>(data);
            }

            componentUpdateRequests.Add(request);
        }

        protected override void OnCreate()
        {
            previous_0 = new NativeList<T0>(Allocator.Persistent);
            previous_1 = new NativeList<T1>(Allocator.Persistent);
            executedQueries = new NativeList<Guid>(Allocator.Persistent);
            componentUpdateRequests = new NativeList<ComponentDataUpdateRequest>(Allocator.Persistent);

            base.OnCreate();
        }

        protected override void OnDestroy()
        {
            previous_0.Dispose();
            previous_1.Dispose();
            executedQueries.Dispose();
            componentUpdateRequests.Dispose();

            base.OnDestroy();
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct UpdateComponentsJob : IJobForEachWithEntity<T0, T1>
        {
            [ReadOnly] public NativeList<ComponentDataUpdateRequest> componentUpdateRequests;

            public void Execute(Entity entity, int index, ref T0 t0, ref T1 t1)
            {
                for (var i = 0; i < componentUpdateRequests.Length; i++)
                {
                    var request = componentUpdateRequests[i];
                    if (request.componentIndex == 0 && request.index == index)
                    {
                        t0 = request.data_0;
                    }
                    if (request.componentIndex == 1 && request.index == index)
                    {
                        t1 = request.data_1;
                    }
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct ProcessQueriesJob : IJob
        {
            [WriteOnly] public NativeList<Guid> queriesToExecute;
            [WriteOnly] public NativeList<T0> previous_0;
            [WriteOnly] public NativeList<T1> previous_1;

            public NativeList<Guid> executedQueries;

            [ReadOnly] public NativeList<int> previousHashCodes_0;
            [ReadOnly] public NativeList<int> hashCodes_0;
            [ReadOnly] public NativeArray<T0> current_0;
            [ReadOnly] public NativeList<int> previousHashCodes_1;
            [ReadOnly] public NativeList<int> hashCodes_1;
            [ReadOnly] public NativeArray<T1> current_1;
            [ReadOnly] public NativeList<Guid> allQueries;

            public void Execute()
            {
                if (!ListEquals(previousHashCodes_0, hashCodes_0))
                {
                    executedQueries.Clear();
                    previous_0.Clear();
                    previous_0.AddRange(current_0);
                }
                else if (!ListEquals(previousHashCodes_1, hashCodes_1))
                {
                    executedQueries.Clear();
                    previous_1.Clear();
                    previous_1.AddRange(current_1);
                }

                for (var i = 0; i < allQueries.Length; i++)
                {
                    if (!ListContains(executedQueries, allQueries[i]))
                    {
                        queriesToExecute.Add(allQueries[i]);
                        executedQueries.Add(allQueries[i]);
                    }
                }
            }

            private bool ListEquals(NativeList<int> list1, NativeList<int> list2)
            {
                if (list1.Length != list2.Length) return false;

                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] != list2[i]) return false;
                }

                return true;
            }

            private bool ListContains(NativeList<Guid> list1, Guid element)
            {
                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] == element) return true;
                }

                return false;
            }
        }

        protected override JobHandle OnUpdate(JobHandle inputDeps)
        {
            var currentTime = Time.ElapsedTime * 1000;
            if (currentTime - lastTimeRun > 25) {
                lastTimeRun = currentTime;
            } else {
                return inputDeps;
            }
            if (queryIds.Length == 0) return inputDeps;

            var hashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var queriesToExecute = new NativeList<Guid>(Allocator.TempJob);

            var updateJob = new UpdateComponentsJob()
            {
                componentUpdateRequests = componentUpdateRequests
            };

            inputDeps = updateJob.Schedule(this, inputDeps);

            inputDeps.Complete();

            var query = EntityManager.CreateEntityQuery(typeof(T0), typeof(T1));

            var list_0 = query.ToComponentDataArray<T0>(Allocator.TempJob);
            var list_1 = query.ToComponentDataArray<T1>(Allocator.TempJob);

            for (var i = 0; i < list_0.Length; i++)
            {
                hashCodes_0.Add(list_0[i].GetHashCode());
            }

            for (var i = 0; i < previous_0.Length; i++)
            {
                previousHashCodes_0.Add(previous_0[i].GetHashCode());
            }
            for (var i = 0; i < list_1.Length; i++)
            {
                hashCodes_1.Add(list_1[i].GetHashCode());
            }

            for (var i = 0; i < previous_1.Length; i++)
            {
                previousHashCodes_1.Add(previous_1[i].GetHashCode());
            }
            var queriesJob = new ProcessQueriesJob()
            {
                executedQueries = executedQueries,
                allQueries = queryIds,
                current_0 = list_0,
                hashCodes_0 = hashCodes_0,
                previous_0 = previous_0,
                previousHashCodes_0 = previousHashCodes_0,
                current_1 = list_1,
                hashCodes_1 = hashCodes_1,
                previous_1 = previous_1,
                previousHashCodes_1 = previousHashCodes_1,
                queriesToExecute = queriesToExecute
            };

            inputDeps = queriesJob.Schedule(inputDeps);

            inputDeps.Complete();

            var listOfJsonLists = new List<string>();
            listOfJsonLists.Add(ListToJson(list_0));
            listOfJsonLists.Add(ListToJson(list_1));
            var resultJson = $"[{string.Join(",", listOfJsonLists)}]";

            foreach (var queryId in queriesToExecute)
            {
                ReactRenderer.Current.AddMessageToBuffer(
                    NativeToJsBridgePayload.BridgeMessage.CreateUpdateComponentDataHookMessage(
                        queryId.ToString(), resultJson));
            }

            list_0.Dispose();
            hashCodes_0.Dispose();
            previousHashCodes_0.Dispose();
            list_1.Dispose();
            hashCodes_1.Dispose();
            previousHashCodes_1.Dispose();
            queriesToExecute.Dispose();
            componentUpdateRequests.Clear();

            return inputDeps;
        }
    }
    public abstract class ReactUIElementsQuery<T0, T1, T2> : ReactUIElementsQuery
    where T0 : struct, IComponentData
    where T1 : struct, IComponentData
    where T2 : struct, IComponentData
    {
        private NativeList<T0> previous_0;
        private NativeList<T1> previous_1;
        private NativeList<T2> previous_2;
        private NativeList<ComponentDataUpdateRequest> componentUpdateRequests;
        private double lastTimeRun;

        [StructLayout(LayoutKind.Sequential)]
        private struct ComponentDataUpdateRequest
        {
            public int componentIndex;
            public int index;
            public T0 data_0;
            public T1 data_1;
            public T2 data_2;
        }

        public override void AddComponentDataUpdateRequest(int componentIndex, int index, string data)
        {
            var request = new ComponentDataUpdateRequest()
            {
                index = index,
                componentIndex = componentIndex
            };

            if (componentIndex == 0) {
                request.data_0 = JsonUtility.FromJson<T0>(data);
            }
            if (componentIndex == 1) {
                request.data_1 = JsonUtility.FromJson<T1>(data);
            }
            if (componentIndex == 2) {
                request.data_2 = JsonUtility.FromJson<T2>(data);
            }

            componentUpdateRequests.Add(request);
        }

        protected override void OnCreate()
        {
            previous_0 = new NativeList<T0>(Allocator.Persistent);
            previous_1 = new NativeList<T1>(Allocator.Persistent);
            previous_2 = new NativeList<T2>(Allocator.Persistent);
            executedQueries = new NativeList<Guid>(Allocator.Persistent);
            componentUpdateRequests = new NativeList<ComponentDataUpdateRequest>(Allocator.Persistent);

            base.OnCreate();
        }

        protected override void OnDestroy()
        {
            previous_0.Dispose();
            previous_1.Dispose();
            previous_2.Dispose();
            executedQueries.Dispose();
            componentUpdateRequests.Dispose();

            base.OnDestroy();
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct UpdateComponentsJob : IJobForEachWithEntity<T0, T1, T2>
        {
            [ReadOnly] public NativeList<ComponentDataUpdateRequest> componentUpdateRequests;

            public void Execute(Entity entity, int index, ref T0 t0, ref T1 t1, ref T2 t2)
            {
                for (var i = 0; i < componentUpdateRequests.Length; i++)
                {
                    var request = componentUpdateRequests[i];
                    if (request.componentIndex == 0 && request.index == index)
                    {
                        t0 = request.data_0;
                    }
                    if (request.componentIndex == 1 && request.index == index)
                    {
                        t1 = request.data_1;
                    }
                    if (request.componentIndex == 2 && request.index == index)
                    {
                        t2 = request.data_2;
                    }
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct ProcessQueriesJob : IJob
        {
            [WriteOnly] public NativeList<Guid> queriesToExecute;
            [WriteOnly] public NativeList<T0> previous_0;
            [WriteOnly] public NativeList<T1> previous_1;
            [WriteOnly] public NativeList<T2> previous_2;

            public NativeList<Guid> executedQueries;

            [ReadOnly] public NativeList<int> previousHashCodes_0;
            [ReadOnly] public NativeList<int> hashCodes_0;
            [ReadOnly] public NativeArray<T0> current_0;
            [ReadOnly] public NativeList<int> previousHashCodes_1;
            [ReadOnly] public NativeList<int> hashCodes_1;
            [ReadOnly] public NativeArray<T1> current_1;
            [ReadOnly] public NativeList<int> previousHashCodes_2;
            [ReadOnly] public NativeList<int> hashCodes_2;
            [ReadOnly] public NativeArray<T2> current_2;
            [ReadOnly] public NativeList<Guid> allQueries;

            public void Execute()
            {
                if (!ListEquals(previousHashCodes_0, hashCodes_0))
                {
                    executedQueries.Clear();
                    previous_0.Clear();
                    previous_0.AddRange(current_0);
                }
                else if (!ListEquals(previousHashCodes_1, hashCodes_1))
                {
                    executedQueries.Clear();
                    previous_1.Clear();
                    previous_1.AddRange(current_1);
                }
                else if (!ListEquals(previousHashCodes_2, hashCodes_2))
                {
                    executedQueries.Clear();
                    previous_2.Clear();
                    previous_2.AddRange(current_2);
                }

                for (var i = 0; i < allQueries.Length; i++)
                {
                    if (!ListContains(executedQueries, allQueries[i]))
                    {
                        queriesToExecute.Add(allQueries[i]);
                        executedQueries.Add(allQueries[i]);
                    }
                }
            }

            private bool ListEquals(NativeList<int> list1, NativeList<int> list2)
            {
                if (list1.Length != list2.Length) return false;

                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] != list2[i]) return false;
                }

                return true;
            }

            private bool ListContains(NativeList<Guid> list1, Guid element)
            {
                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] == element) return true;
                }

                return false;
            }
        }

        protected override JobHandle OnUpdate(JobHandle inputDeps)
        {
            var currentTime = Time.ElapsedTime * 1000;
            if (currentTime - lastTimeRun > 25) {
                lastTimeRun = currentTime;
            } else {
                return inputDeps;
            }
            if (queryIds.Length == 0) return inputDeps;

            var hashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_2 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_2 = new NativeList<int>(Allocator.TempJob);
            var queriesToExecute = new NativeList<Guid>(Allocator.TempJob);

            var updateJob = new UpdateComponentsJob()
            {
                componentUpdateRequests = componentUpdateRequests
            };

            inputDeps = updateJob.Schedule(this, inputDeps);

            inputDeps.Complete();

            var query = EntityManager.CreateEntityQuery(typeof(T0), typeof(T1), typeof(T2));

            var list_0 = query.ToComponentDataArray<T0>(Allocator.TempJob);
            var list_1 = query.ToComponentDataArray<T1>(Allocator.TempJob);
            var list_2 = query.ToComponentDataArray<T2>(Allocator.TempJob);

            for (var i = 0; i < list_0.Length; i++)
            {
                hashCodes_0.Add(list_0[i].GetHashCode());
            }

            for (var i = 0; i < previous_0.Length; i++)
            {
                previousHashCodes_0.Add(previous_0[i].GetHashCode());
            }
            for (var i = 0; i < list_1.Length; i++)
            {
                hashCodes_1.Add(list_1[i].GetHashCode());
            }

            for (var i = 0; i < previous_1.Length; i++)
            {
                previousHashCodes_1.Add(previous_1[i].GetHashCode());
            }
            for (var i = 0; i < list_2.Length; i++)
            {
                hashCodes_2.Add(list_2[i].GetHashCode());
            }

            for (var i = 0; i < previous_2.Length; i++)
            {
                previousHashCodes_2.Add(previous_2[i].GetHashCode());
            }
            var queriesJob = new ProcessQueriesJob()
            {
                executedQueries = executedQueries,
                allQueries = queryIds,
                current_0 = list_0,
                hashCodes_0 = hashCodes_0,
                previous_0 = previous_0,
                previousHashCodes_0 = previousHashCodes_0,
                current_1 = list_1,
                hashCodes_1 = hashCodes_1,
                previous_1 = previous_1,
                previousHashCodes_1 = previousHashCodes_1,
                current_2 = list_2,
                hashCodes_2 = hashCodes_2,
                previous_2 = previous_2,
                previousHashCodes_2 = previousHashCodes_2,
                queriesToExecute = queriesToExecute
            };

            inputDeps = queriesJob.Schedule(inputDeps);

            inputDeps.Complete();

            var listOfJsonLists = new List<string>();
            listOfJsonLists.Add(ListToJson(list_0));
            listOfJsonLists.Add(ListToJson(list_1));
            listOfJsonLists.Add(ListToJson(list_2));
            var resultJson = $"[{string.Join(",", listOfJsonLists)}]";

            foreach (var queryId in queriesToExecute)
            {
                ReactRenderer.Current.AddMessageToBuffer(
                    NativeToJsBridgePayload.BridgeMessage.CreateUpdateComponentDataHookMessage(
                        queryId.ToString(), resultJson));
            }

            list_0.Dispose();
            hashCodes_0.Dispose();
            previousHashCodes_0.Dispose();
            list_1.Dispose();
            hashCodes_1.Dispose();
            previousHashCodes_1.Dispose();
            list_2.Dispose();
            hashCodes_2.Dispose();
            previousHashCodes_2.Dispose();
            queriesToExecute.Dispose();
            componentUpdateRequests.Clear();

            return inputDeps;
        }
    }
    public abstract class ReactUIElementsQuery<T0, T1, T2, T3> : ReactUIElementsQuery
    where T0 : struct, IComponentData
    where T1 : struct, IComponentData
    where T2 : struct, IComponentData
    where T3 : struct, IComponentData
    {
        private NativeList<T0> previous_0;
        private NativeList<T1> previous_1;
        private NativeList<T2> previous_2;
        private NativeList<T3> previous_3;
        private NativeList<ComponentDataUpdateRequest> componentUpdateRequests;
        private double lastTimeRun;

        [StructLayout(LayoutKind.Sequential)]
        private struct ComponentDataUpdateRequest
        {
            public int componentIndex;
            public int index;
            public T0 data_0;
            public T1 data_1;
            public T2 data_2;
            public T3 data_3;
        }

        public override void AddComponentDataUpdateRequest(int componentIndex, int index, string data)
        {
            var request = new ComponentDataUpdateRequest()
            {
                index = index,
                componentIndex = componentIndex
            };

            if (componentIndex == 0) {
                request.data_0 = JsonUtility.FromJson<T0>(data);
            }
            if (componentIndex == 1) {
                request.data_1 = JsonUtility.FromJson<T1>(data);
            }
            if (componentIndex == 2) {
                request.data_2 = JsonUtility.FromJson<T2>(data);
            }
            if (componentIndex == 3) {
                request.data_3 = JsonUtility.FromJson<T3>(data);
            }

            componentUpdateRequests.Add(request);
        }

        protected override void OnCreate()
        {
            previous_0 = new NativeList<T0>(Allocator.Persistent);
            previous_1 = new NativeList<T1>(Allocator.Persistent);
            previous_2 = new NativeList<T2>(Allocator.Persistent);
            previous_3 = new NativeList<T3>(Allocator.Persistent);
            executedQueries = new NativeList<Guid>(Allocator.Persistent);
            componentUpdateRequests = new NativeList<ComponentDataUpdateRequest>(Allocator.Persistent);

            base.OnCreate();
        }

        protected override void OnDestroy()
        {
            previous_0.Dispose();
            previous_1.Dispose();
            previous_2.Dispose();
            previous_3.Dispose();
            executedQueries.Dispose();
            componentUpdateRequests.Dispose();

            base.OnDestroy();
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct UpdateComponentsJob : IJobForEachWithEntity<T0, T1, T2, T3>
        {
            [ReadOnly] public NativeList<ComponentDataUpdateRequest> componentUpdateRequests;

            public void Execute(Entity entity, int index, ref T0 t0, ref T1 t1, ref T2 t2, ref T3 t3)
            {
                for (var i = 0; i < componentUpdateRequests.Length; i++)
                {
                    var request = componentUpdateRequests[i];
                    if (request.componentIndex == 0 && request.index == index)
                    {
                        t0 = request.data_0;
                    }
                    if (request.componentIndex == 1 && request.index == index)
                    {
                        t1 = request.data_1;
                    }
                    if (request.componentIndex == 2 && request.index == index)
                    {
                        t2 = request.data_2;
                    }
                    if (request.componentIndex == 3 && request.index == index)
                    {
                        t3 = request.data_3;
                    }
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct ProcessQueriesJob : IJob
        {
            [WriteOnly] public NativeList<Guid> queriesToExecute;
            [WriteOnly] public NativeList<T0> previous_0;
            [WriteOnly] public NativeList<T1> previous_1;
            [WriteOnly] public NativeList<T2> previous_2;
            [WriteOnly] public NativeList<T3> previous_3;

            public NativeList<Guid> executedQueries;

            [ReadOnly] public NativeList<int> previousHashCodes_0;
            [ReadOnly] public NativeList<int> hashCodes_0;
            [ReadOnly] public NativeArray<T0> current_0;
            [ReadOnly] public NativeList<int> previousHashCodes_1;
            [ReadOnly] public NativeList<int> hashCodes_1;
            [ReadOnly] public NativeArray<T1> current_1;
            [ReadOnly] public NativeList<int> previousHashCodes_2;
            [ReadOnly] public NativeList<int> hashCodes_2;
            [ReadOnly] public NativeArray<T2> current_2;
            [ReadOnly] public NativeList<int> previousHashCodes_3;
            [ReadOnly] public NativeList<int> hashCodes_3;
            [ReadOnly] public NativeArray<T3> current_3;
            [ReadOnly] public NativeList<Guid> allQueries;

            public void Execute()
            {
                if (!ListEquals(previousHashCodes_0, hashCodes_0))
                {
                    executedQueries.Clear();
                    previous_0.Clear();
                    previous_0.AddRange(current_0);
                }
                else if (!ListEquals(previousHashCodes_1, hashCodes_1))
                {
                    executedQueries.Clear();
                    previous_1.Clear();
                    previous_1.AddRange(current_1);
                }
                else if (!ListEquals(previousHashCodes_2, hashCodes_2))
                {
                    executedQueries.Clear();
                    previous_2.Clear();
                    previous_2.AddRange(current_2);
                }
                else if (!ListEquals(previousHashCodes_3, hashCodes_3))
                {
                    executedQueries.Clear();
                    previous_3.Clear();
                    previous_3.AddRange(current_3);
                }

                for (var i = 0; i < allQueries.Length; i++)
                {
                    if (!ListContains(executedQueries, allQueries[i]))
                    {
                        queriesToExecute.Add(allQueries[i]);
                        executedQueries.Add(allQueries[i]);
                    }
                }
            }

            private bool ListEquals(NativeList<int> list1, NativeList<int> list2)
            {
                if (list1.Length != list2.Length) return false;

                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] != list2[i]) return false;
                }

                return true;
            }

            private bool ListContains(NativeList<Guid> list1, Guid element)
            {
                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] == element) return true;
                }

                return false;
            }
        }

        protected override JobHandle OnUpdate(JobHandle inputDeps)
        {
            var currentTime = Time.ElapsedTime * 1000;
            if (currentTime - lastTimeRun > 25) {
                lastTimeRun = currentTime;
            } else {
                return inputDeps;
            }
            if (queryIds.Length == 0) return inputDeps;

            var hashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_2 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_2 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_3 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_3 = new NativeList<int>(Allocator.TempJob);
            var queriesToExecute = new NativeList<Guid>(Allocator.TempJob);

            var updateJob = new UpdateComponentsJob()
            {
                componentUpdateRequests = componentUpdateRequests
            };

            inputDeps = updateJob.Schedule(this, inputDeps);

            inputDeps.Complete();

            var query = EntityManager.CreateEntityQuery(typeof(T0), typeof(T1), typeof(T2), typeof(T3));

            var list_0 = query.ToComponentDataArray<T0>(Allocator.TempJob);
            var list_1 = query.ToComponentDataArray<T1>(Allocator.TempJob);
            var list_2 = query.ToComponentDataArray<T2>(Allocator.TempJob);
            var list_3 = query.ToComponentDataArray<T3>(Allocator.TempJob);

            for (var i = 0; i < list_0.Length; i++)
            {
                hashCodes_0.Add(list_0[i].GetHashCode());
            }

            for (var i = 0; i < previous_0.Length; i++)
            {
                previousHashCodes_0.Add(previous_0[i].GetHashCode());
            }
            for (var i = 0; i < list_1.Length; i++)
            {
                hashCodes_1.Add(list_1[i].GetHashCode());
            }

            for (var i = 0; i < previous_1.Length; i++)
            {
                previousHashCodes_1.Add(previous_1[i].GetHashCode());
            }
            for (var i = 0; i < list_2.Length; i++)
            {
                hashCodes_2.Add(list_2[i].GetHashCode());
            }

            for (var i = 0; i < previous_2.Length; i++)
            {
                previousHashCodes_2.Add(previous_2[i].GetHashCode());
            }
            for (var i = 0; i < list_3.Length; i++)
            {
                hashCodes_3.Add(list_3[i].GetHashCode());
            }

            for (var i = 0; i < previous_3.Length; i++)
            {
                previousHashCodes_3.Add(previous_3[i].GetHashCode());
            }
            var queriesJob = new ProcessQueriesJob()
            {
                executedQueries = executedQueries,
                allQueries = queryIds,
                current_0 = list_0,
                hashCodes_0 = hashCodes_0,
                previous_0 = previous_0,
                previousHashCodes_0 = previousHashCodes_0,
                current_1 = list_1,
                hashCodes_1 = hashCodes_1,
                previous_1 = previous_1,
                previousHashCodes_1 = previousHashCodes_1,
                current_2 = list_2,
                hashCodes_2 = hashCodes_2,
                previous_2 = previous_2,
                previousHashCodes_2 = previousHashCodes_2,
                current_3 = list_3,
                hashCodes_3 = hashCodes_3,
                previous_3 = previous_3,
                previousHashCodes_3 = previousHashCodes_3,
                queriesToExecute = queriesToExecute
            };

            inputDeps = queriesJob.Schedule(inputDeps);

            inputDeps.Complete();

            var listOfJsonLists = new List<string>();
            listOfJsonLists.Add(ListToJson(list_0));
            listOfJsonLists.Add(ListToJson(list_1));
            listOfJsonLists.Add(ListToJson(list_2));
            listOfJsonLists.Add(ListToJson(list_3));
            var resultJson = $"[{string.Join(",", listOfJsonLists)}]";

            foreach (var queryId in queriesToExecute)
            {
                ReactRenderer.Current.AddMessageToBuffer(
                    NativeToJsBridgePayload.BridgeMessage.CreateUpdateComponentDataHookMessage(
                        queryId.ToString(), resultJson));
            }

            list_0.Dispose();
            hashCodes_0.Dispose();
            previousHashCodes_0.Dispose();
            list_1.Dispose();
            hashCodes_1.Dispose();
            previousHashCodes_1.Dispose();
            list_2.Dispose();
            hashCodes_2.Dispose();
            previousHashCodes_2.Dispose();
            list_3.Dispose();
            hashCodes_3.Dispose();
            previousHashCodes_3.Dispose();
            queriesToExecute.Dispose();
            componentUpdateRequests.Clear();

            return inputDeps;
        }
    }
    public abstract class ReactUIElementsQuery<T0, T1, T2, T3, T4> : ReactUIElementsQuery
    where T0 : struct, IComponentData
    where T1 : struct, IComponentData
    where T2 : struct, IComponentData
    where T3 : struct, IComponentData
    where T4 : struct, IComponentData
    {
        private NativeList<T0> previous_0;
        private NativeList<T1> previous_1;
        private NativeList<T2> previous_2;
        private NativeList<T3> previous_3;
        private NativeList<T4> previous_4;
        private NativeList<ComponentDataUpdateRequest> componentUpdateRequests;
        private double lastTimeRun;

        [StructLayout(LayoutKind.Sequential)]
        private struct ComponentDataUpdateRequest
        {
            public int componentIndex;
            public int index;
            public T0 data_0;
            public T1 data_1;
            public T2 data_2;
            public T3 data_3;
            public T4 data_4;
        }

        public override void AddComponentDataUpdateRequest(int componentIndex, int index, string data)
        {
            var request = new ComponentDataUpdateRequest()
            {
                index = index,
                componentIndex = componentIndex
            };

            if (componentIndex == 0) {
                request.data_0 = JsonUtility.FromJson<T0>(data);
            }
            if (componentIndex == 1) {
                request.data_1 = JsonUtility.FromJson<T1>(data);
            }
            if (componentIndex == 2) {
                request.data_2 = JsonUtility.FromJson<T2>(data);
            }
            if (componentIndex == 3) {
                request.data_3 = JsonUtility.FromJson<T3>(data);
            }
            if (componentIndex == 4) {
                request.data_4 = JsonUtility.FromJson<T4>(data);
            }

            componentUpdateRequests.Add(request);
        }

        protected override void OnCreate()
        {
            previous_0 = new NativeList<T0>(Allocator.Persistent);
            previous_1 = new NativeList<T1>(Allocator.Persistent);
            previous_2 = new NativeList<T2>(Allocator.Persistent);
            previous_3 = new NativeList<T3>(Allocator.Persistent);
            previous_4 = new NativeList<T4>(Allocator.Persistent);
            executedQueries = new NativeList<Guid>(Allocator.Persistent);
            componentUpdateRequests = new NativeList<ComponentDataUpdateRequest>(Allocator.Persistent);

            base.OnCreate();
        }

        protected override void OnDestroy()
        {
            previous_0.Dispose();
            previous_1.Dispose();
            previous_2.Dispose();
            previous_3.Dispose();
            previous_4.Dispose();
            executedQueries.Dispose();
            componentUpdateRequests.Dispose();

            base.OnDestroy();
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct UpdateComponentsJob : IJobForEachWithEntity<T0, T1, T2, T3, T4>
        {
            [ReadOnly] public NativeList<ComponentDataUpdateRequest> componentUpdateRequests;

            public void Execute(Entity entity, int index, ref T0 t0, ref T1 t1, ref T2 t2, ref T3 t3, ref T4 t4)
            {
                for (var i = 0; i < componentUpdateRequests.Length; i++)
                {
                    var request = componentUpdateRequests[i];
                    if (request.componentIndex == 0 && request.index == index)
                    {
                        t0 = request.data_0;
                    }
                    if (request.componentIndex == 1 && request.index == index)
                    {
                        t1 = request.data_1;
                    }
                    if (request.componentIndex == 2 && request.index == index)
                    {
                        t2 = request.data_2;
                    }
                    if (request.componentIndex == 3 && request.index == index)
                    {
                        t3 = request.data_3;
                    }
                    if (request.componentIndex == 4 && request.index == index)
                    {
                        t4 = request.data_4;
                    }
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct ProcessQueriesJob : IJob
        {
            [WriteOnly] public NativeList<Guid> queriesToExecute;
            [WriteOnly] public NativeList<T0> previous_0;
            [WriteOnly] public NativeList<T1> previous_1;
            [WriteOnly] public NativeList<T2> previous_2;
            [WriteOnly] public NativeList<T3> previous_3;
            [WriteOnly] public NativeList<T4> previous_4;

            public NativeList<Guid> executedQueries;

            [ReadOnly] public NativeList<int> previousHashCodes_0;
            [ReadOnly] public NativeList<int> hashCodes_0;
            [ReadOnly] public NativeArray<T0> current_0;
            [ReadOnly] public NativeList<int> previousHashCodes_1;
            [ReadOnly] public NativeList<int> hashCodes_1;
            [ReadOnly] public NativeArray<T1> current_1;
            [ReadOnly] public NativeList<int> previousHashCodes_2;
            [ReadOnly] public NativeList<int> hashCodes_2;
            [ReadOnly] public NativeArray<T2> current_2;
            [ReadOnly] public NativeList<int> previousHashCodes_3;
            [ReadOnly] public NativeList<int> hashCodes_3;
            [ReadOnly] public NativeArray<T3> current_3;
            [ReadOnly] public NativeList<int> previousHashCodes_4;
            [ReadOnly] public NativeList<int> hashCodes_4;
            [ReadOnly] public NativeArray<T4> current_4;
            [ReadOnly] public NativeList<Guid> allQueries;

            public void Execute()
            {
                if (!ListEquals(previousHashCodes_0, hashCodes_0))
                {
                    executedQueries.Clear();
                    previous_0.Clear();
                    previous_0.AddRange(current_0);
                }
                else if (!ListEquals(previousHashCodes_1, hashCodes_1))
                {
                    executedQueries.Clear();
                    previous_1.Clear();
                    previous_1.AddRange(current_1);
                }
                else if (!ListEquals(previousHashCodes_2, hashCodes_2))
                {
                    executedQueries.Clear();
                    previous_2.Clear();
                    previous_2.AddRange(current_2);
                }
                else if (!ListEquals(previousHashCodes_3, hashCodes_3))
                {
                    executedQueries.Clear();
                    previous_3.Clear();
                    previous_3.AddRange(current_3);
                }
                else if (!ListEquals(previousHashCodes_4, hashCodes_4))
                {
                    executedQueries.Clear();
                    previous_4.Clear();
                    previous_4.AddRange(current_4);
                }

                for (var i = 0; i < allQueries.Length; i++)
                {
                    if (!ListContains(executedQueries, allQueries[i]))
                    {
                        queriesToExecute.Add(allQueries[i]);
                        executedQueries.Add(allQueries[i]);
                    }
                }
            }

            private bool ListEquals(NativeList<int> list1, NativeList<int> list2)
            {
                if (list1.Length != list2.Length) return false;

                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] != list2[i]) return false;
                }

                return true;
            }

            private bool ListContains(NativeList<Guid> list1, Guid element)
            {
                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] == element) return true;
                }

                return false;
            }
        }

        protected override JobHandle OnUpdate(JobHandle inputDeps)
        {
            var currentTime = Time.ElapsedTime * 1000;
            if (currentTime - lastTimeRun > 25) {
                lastTimeRun = currentTime;
            } else {
                return inputDeps;
            }
            if (queryIds.Length == 0) return inputDeps;

            var hashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_0 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_1 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_2 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_2 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_3 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_3 = new NativeList<int>(Allocator.TempJob);
            var hashCodes_4 = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_4 = new NativeList<int>(Allocator.TempJob);
            var queriesToExecute = new NativeList<Guid>(Allocator.TempJob);

            var updateJob = new UpdateComponentsJob()
            {
                componentUpdateRequests = componentUpdateRequests
            };

            inputDeps = updateJob.Schedule(this, inputDeps);

            inputDeps.Complete();

            var query = EntityManager.CreateEntityQuery(typeof(T0), typeof(T1), typeof(T2), typeof(T3), typeof(T4));

            var list_0 = query.ToComponentDataArray<T0>(Allocator.TempJob);
            var list_1 = query.ToComponentDataArray<T1>(Allocator.TempJob);
            var list_2 = query.ToComponentDataArray<T2>(Allocator.TempJob);
            var list_3 = query.ToComponentDataArray<T3>(Allocator.TempJob);
            var list_4 = query.ToComponentDataArray<T4>(Allocator.TempJob);

            for (var i = 0; i < list_0.Length; i++)
            {
                hashCodes_0.Add(list_0[i].GetHashCode());
            }

            for (var i = 0; i < previous_0.Length; i++)
            {
                previousHashCodes_0.Add(previous_0[i].GetHashCode());
            }
            for (var i = 0; i < list_1.Length; i++)
            {
                hashCodes_1.Add(list_1[i].GetHashCode());
            }

            for (var i = 0; i < previous_1.Length; i++)
            {
                previousHashCodes_1.Add(previous_1[i].GetHashCode());
            }
            for (var i = 0; i < list_2.Length; i++)
            {
                hashCodes_2.Add(list_2[i].GetHashCode());
            }

            for (var i = 0; i < previous_2.Length; i++)
            {
                previousHashCodes_2.Add(previous_2[i].GetHashCode());
            }
            for (var i = 0; i < list_3.Length; i++)
            {
                hashCodes_3.Add(list_3[i].GetHashCode());
            }

            for (var i = 0; i < previous_3.Length; i++)
            {
                previousHashCodes_3.Add(previous_3[i].GetHashCode());
            }
            for (var i = 0; i < list_4.Length; i++)
            {
                hashCodes_4.Add(list_4[i].GetHashCode());
            }

            for (var i = 0; i < previous_4.Length; i++)
            {
                previousHashCodes_4.Add(previous_4[i].GetHashCode());
            }
            var queriesJob = new ProcessQueriesJob()
            {
                executedQueries = executedQueries,
                allQueries = queryIds,
                current_0 = list_0,
                hashCodes_0 = hashCodes_0,
                previous_0 = previous_0,
                previousHashCodes_0 = previousHashCodes_0,
                current_1 = list_1,
                hashCodes_1 = hashCodes_1,
                previous_1 = previous_1,
                previousHashCodes_1 = previousHashCodes_1,
                current_2 = list_2,
                hashCodes_2 = hashCodes_2,
                previous_2 = previous_2,
                previousHashCodes_2 = previousHashCodes_2,
                current_3 = list_3,
                hashCodes_3 = hashCodes_3,
                previous_3 = previous_3,
                previousHashCodes_3 = previousHashCodes_3,
                current_4 = list_4,
                hashCodes_4 = hashCodes_4,
                previous_4 = previous_4,
                previousHashCodes_4 = previousHashCodes_4,
                queriesToExecute = queriesToExecute
            };

            inputDeps = queriesJob.Schedule(inputDeps);

            inputDeps.Complete();

            var listOfJsonLists = new List<string>();
            listOfJsonLists.Add(ListToJson(list_0));
            listOfJsonLists.Add(ListToJson(list_1));
            listOfJsonLists.Add(ListToJson(list_2));
            listOfJsonLists.Add(ListToJson(list_3));
            listOfJsonLists.Add(ListToJson(list_4));
            var resultJson = $"[{string.Join(",", listOfJsonLists)}]";

            foreach (var queryId in queriesToExecute)
            {
                ReactRenderer.Current.AddMessageToBuffer(
                    NativeToJsBridgePayload.BridgeMessage.CreateUpdateComponentDataHookMessage(
                        queryId.ToString(), resultJson));
            }

            list_0.Dispose();
            hashCodes_0.Dispose();
            previousHashCodes_0.Dispose();
            list_1.Dispose();
            hashCodes_1.Dispose();
            previousHashCodes_1.Dispose();
            list_2.Dispose();
            hashCodes_2.Dispose();
            previousHashCodes_2.Dispose();
            list_3.Dispose();
            hashCodes_3.Dispose();
            previousHashCodes_3.Dispose();
            list_4.Dispose();
            hashCodes_4.Dispose();
            previousHashCodes_4.Dispose();
            queriesToExecute.Dispose();
            componentUpdateRequests.Clear();

            return inputDeps;
        }
    }
}