<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<# Func<int, string> GetGenericArgs = (int argumentCount) => {
    var strList = new List<string>();
    for (var i = 0; i < argumentCount; i++) strList.Add("T" + i);
    return string.Join(", ", strList);
}; #>
<# Func<int, string> GetJobParams = (int argumentCount) => {
    var strList = new List<string>();
    for (var i = 0; i < argumentCount; i++) strList.Add("ref T" + i + " t" + i);
    return string.Join(", ", strList);
}; #>
<# Func<int, string> GetTypeofs = (int argumentCount) => {
    var strList = new List<string>();
    for (var i = 0; i < argumentCount; i++) strList.Add("typeof(T" + i + ")");
    return string.Join(", ", strList);
}; #>
<# Action<int> RenderClass = (int argumentCount) => { #>
    public abstract class ReactUIElementsQuery<<#=GetGenericArgs(argumentCount)#>> : ReactUIElementsQuery
<# for (int i = 0; i < argumentCount; i ++) { #>
    where T<#=i#> : struct, IComponentData
<#}#>
    {
<# for (int i = 0; i < argumentCount; i ++) { #>
        private NativeList<T<#=i#>> previous_<#=i#>;
<#}#>
        private NativeList<ComponentDataUpdateRequest> componentUpdateRequests;
        private double lastTimeRun;

        [StructLayout(LayoutKind.Sequential)]
        private struct ComponentDataUpdateRequest
        {
            public int componentIndex;
            public int index;
<# for (int i = 0; i < argumentCount; i ++) { #>
            public T<#=i#> data_<#=i#>;
<#}#>
        }

        public override void AddComponentDataUpdateRequest(int componentIndex, int index, string data)
        {
            var request = new ComponentDataUpdateRequest()
            {
                index = index,
                componentIndex = componentIndex
            };

<# for (int i = 0; i < argumentCount; i ++) { #>
            if (componentIndex == <#=i#>) {
                request.data_<#=i#> = JsonUtility.FromJson<T<#=i#>>(data);
            }
<#}#>

            componentUpdateRequests.Add(request);
        }

        protected override void OnCreate()
        {
<# for (int i = 0; i < argumentCount; i ++) { #>
            previous_<#=i#> = new NativeList<T<#=i#>>(Allocator.Persistent);
<#}#>
            executedQueries = new NativeList<Guid>(Allocator.Persistent);
            componentUpdateRequests = new NativeList<ComponentDataUpdateRequest>(Allocator.Persistent);

            base.OnCreate();
        }

        protected override void OnDestroy()
        {
<# for (int i = 0; i < argumentCount; i ++) { #>
            previous_<#=i#>.Dispose();
<#}#>
            executedQueries.Dispose();
            componentUpdateRequests.Dispose();

            base.OnDestroy();
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct UpdateComponentsJob : IJobForEachWithEntity<<#=GetGenericArgs(argumentCount)#>>
        {
            [ReadOnly] public NativeList<ComponentDataUpdateRequest> componentUpdateRequests;

            public void Execute(Entity entity, int index, <#=GetJobParams(argumentCount)#>)
            {
                for (var i = 0; i < componentUpdateRequests.Length; i++)
                {
                    var request = componentUpdateRequests[i];
<# for (int i = 0; i < argumentCount; i ++) { #>
                    if (request.componentIndex == <#=i#> && request.index == index)
                    {
                        t<#=i#> = request.data_<#=i#>;
                    }
<#}#>
                }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        [BurstCompile]
        private struct ProcessQueriesJob : IJob
        {
            [WriteOnly] public NativeList<Guid> queriesToExecute;
<# for (int i = 0; i < argumentCount; i ++) { #>
            [WriteOnly] public NativeList<T<#=i#>> previous_<#=i#>;
<#}#>

            public NativeList<Guid> executedQueries;

<# for (int i = 0; i < argumentCount; i ++) { #>
            [ReadOnly] public NativeList<int> previousHashCodes_<#=i#>;
            [ReadOnly] public NativeList<int> hashCodes_<#=i#>;
            [ReadOnly] public NativeArray<T<#=i#>> current_<#=i#>;
<#}#>
            [ReadOnly] public NativeList<Guid> allQueries;

            public void Execute()
            {
                if (!ListEquals(previousHashCodes_0, hashCodes_0))
                {
                    executedQueries.Clear();
                    previous_0.Clear();
                    previous_0.AddRange(current_0);
                }
<# for (int i = 1; i < argumentCount; i ++) { #>
                else if (!ListEquals(previousHashCodes_<#=i#>, hashCodes_<#=i#>))
                {
                    executedQueries.Clear();
                    previous_<#=i#>.Clear();
                    previous_<#=i#>.AddRange(current_<#=i#>);
                }
<#}#>

                for (var i = 0; i < allQueries.Length; i++)
                {
                    if (!ListContains(executedQueries, allQueries[i]))
                    {
                        queriesToExecute.Add(allQueries[i]);
                        executedQueries.Add(allQueries[i]);
                    }
                }
            }

            private bool ListEquals(NativeList<int> list1, NativeList<int> list2)
            {
                if (list1.Length != list2.Length) return false;

                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] != list2[i]) return false;
                }

                return true;
            }

            private bool ListContains(NativeList<Guid> list1, Guid element)
            {
                for (var i = 0; i < list1.Length; i++)
                {
                    if (list1[i] == element) return true;
                }

                return false;
            }
        }

        protected override JobHandle OnUpdate(JobHandle inputDeps)
        {
            var currentTime = Time.ElapsedTime * 1000;
            if (currentTime - lastTimeRun > 25) {
                lastTimeRun = currentTime;
            } else {
                return inputDeps;
            }
            if (queryIds.Length == 0) return inputDeps;

<# for (int i = 0; i < argumentCount; i ++) { #>
            var hashCodes_<#=i#> = new NativeList<int>(Allocator.TempJob);
            var previousHashCodes_<#=i#> = new NativeList<int>(Allocator.TempJob);
<#}#>
            var queriesToExecute = new NativeList<Guid>(Allocator.TempJob);

            var updateJob = new UpdateComponentsJob()
            {
                componentUpdateRequests = componentUpdateRequests
            };

            inputDeps = updateJob.Schedule(this, inputDeps);

            inputDeps.Complete();

            var query = EntityManager.CreateEntityQuery(<#=GetTypeofs(argumentCount)#>);

<# for (int i = 0; i < argumentCount; i ++) { #>
            var list_<#=i#> = query.ToComponentDataArray<T<#=i#>>(Allocator.TempJob);
<#}#>

<# for (int i = 0; i < argumentCount; i ++) { #>
            for (var i = 0; i < list_<#=i#>.Length; i++)
            {
                hashCodes_<#=i#>.Add(list_<#=i#>[i].GetHashCode());
            }

            for (var i = 0; i < previous_<#=i#>.Length; i++)
            {
                previousHashCodes_<#=i#>.Add(previous_<#=i#>[i].GetHashCode());
            }
<#}#>
            var queriesJob = new ProcessQueriesJob()
            {
                executedQueries = executedQueries,
                allQueries = queryIds,
<# for (int i = 0; i < argumentCount; i ++) { #>
                current_<#=i#> = list_<#=i#>,
                hashCodes_<#=i#> = hashCodes_<#=i#>,
                previous_<#=i#> = previous_<#=i#>,
                previousHashCodes_<#=i#> = previousHashCodes_<#=i#>,
<#}#>
                queriesToExecute = queriesToExecute
            };

            inputDeps = queriesJob.Schedule(inputDeps);

            inputDeps.Complete();

            var listOfJsonLists = new List<string>();
<# for (int i = 0; i < argumentCount; i ++) { #>
            listOfJsonLists.Add(ListToJson(list_<#=i#>));
<#}#>
            var resultJson = $"[{string.Join(",", listOfJsonLists)}]";

            foreach (var queryId in queriesToExecute)
            {
                ReactRenderer.Current.AddMessageToBuffer(
                    NativeToJsBridgePayload.BridgeMessage.CreateUpdateComponentDataHookMessage(
                        queryId.ToString(), resultJson));
            }

<# for (int i = 0; i < argumentCount; i ++) { #>
            list_<#=i#>.Dispose();
            hashCodes_<#=i#>.Dispose();
            previousHashCodes_<#=i#>.Dispose();
<#}#>
            queriesToExecute.Dispose();
            componentUpdateRequests.Clear();

            return inputDeps;
        }
    }
<# }; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using UnityEngine;
using UnityReactUIElements.Bridge;

namespace UnityReactUIElements
{
<# RenderClass(1); #>
<# RenderClass(2); #>
<# RenderClass(3); #>
<# RenderClass(4); #>
<# RenderClass(5); #>
}